<h2 align="center">Отчет по работе Serializer Test</h2>

<h3 align="center">Условия тестирования</h3>
- Тест проводился на `1_000_000` объектов `Animal`
- Запуск тестов проводился не менее `5` раз
- Было проведено дополнительное тестирование без возможности записи и чтения null-ов
- В таблицу занесены средние 
данные за последние `3` запуска

<h3 align="center">Результаты</h3>
<h4 align="center">До добавления возможности записи и чтения null объектов</h4>

| Type of serialize | Serialization time,<br/>`ms` | Deserialization time,<br/>`ms` | File size,<br/>`bytes` |
|:-----------------:|:----------------------------:|:------------------------------:|:----------------------:|
|      Default      |            22_788            |             39_619             |       53_004_327       |
|   With methods    |            27_126            |             33_973             |       56_714_270       |
| With externalize  |            26_948            |             33_673             |       58_714_940       |
|      Custom       |             783              |             1_469              |       40_711_673       |

<h4 align="center">После добавления возможности записи и чтения null объектов</h4>

| Type of serialize | Serialization time,<br/>`ms` | Deserialization time,<br/>`ms` | File size,<br/>`bytes` |
|:-----------------:|:----------------------------:|:------------------------------:|:----------------------:|
|      Default      |            9_687             |             17_083             |       20_489_962       |
|   With methods    |            13_528            |             14_298             |       21_613_996       |
| With externalize  |            12_830            |             14_716             |       22_342_761       |
|      Custom       |             600              |             1_058              |       15_858_820       |

<h3 align="center">Выводы</h3>
____
> ### ObjectStreams и DataStreams
> Стоит обратить внимание, что если в `custom` сериализации использовать 
`DataStream` вместо `ObjectStream`, получаем значительно уступающие
показатели по времени у `custom`. В последних версиях `Java` была сильно 
оптимизирована JVM для использования `ObjectStreams`, поскольку
это наиболее распространенный способ записи и чтения данных и, таким
образом, находится на критическом пути производительности `Java`. 
>>Приведем в качестве примера тест на `DataStream` с реализацией записи и чтения null:
>>
>>| Type of serialize | Serialization time,<br/>`ms` | Deserialization time,<br/>`ms` | File size,<br/>`bytes` |
>>|:-----------------:|:----------------------------:|:------------------------------:|:----------------------:|
|      Default      |            9_788             |             16_619             |       20_004_327       |
|   With methods    |            12_943            |             14_773             |       21_614_270       |
| With externalize  |            12_009            |             14_008             |       22_314_940       |
|      Custom       |            20_390            |             19_469             |       15_711_673       |
____
>### До добавления возможности записи и чтения null объектов
>`Default` показала лучшие результаты сериализации, чем `with methods` и `externalizable`, благодаря оптимизации.
Внутренний механизм Serializable во время работы генерирует большой объем служебной информации и разного рода
временных данных, предназначен для работы с любым объектом и может хранить данные,
которые не нужны для восстановления состояния объекта. В результате мы имеем большие по
сравнению с `custom` реализацией затраты по памяти и времени.
>____
>`Serialize with methods` и `externalizable` в сумме работают примерно также, как `default`. 
`externalizable` работает быстрее `with methods`, поскольку требует публичный конструктор без аргументов, 
что позволяет экономить время на `reflection`. `With methods` и `externalizable` тратят 
больше памяти, чем `default`, поскольку записывают метаинформацию о классах. 
>____
>`Custom сериализация` показывает лучшие результаты как по времени, так и по памяти. 
В данном виде сериализации записываются и считываются только строки и примитивные типы. Нет необходимости
сохранять большой объем служебной информации.
____
>### После добавления возможности записи и чтения null объектов
> Получили аналогичные результаты, но уже с данными, имеющими примерно в 2 раза меньший размер. 
В процессе реализации `serializer` было замечено, что можно более эффективно 
записывать `null` и `boolean`, теперь они ложатся в один байт. 
