<h2 align="center">Отчет по работе Serializer Test</h2>

### Условия тестирования

- Тест проводился на `1_000_000` объектов `Animal`
- Запуск тестов проводился не менее `5` раз
- Было проведено дополнительное тестирование без обработки null-ов при записи
- В таблицу занесены средние данные за последние `3` запуска

___

### Результаты

#### До добавления возможности обработки null объектов

| Type of serialize | Serialization time,<br/>`ms` | Deserialization time,<br/>`ms` | File size,<br/>`bytes` |
|:-----------------:|:----------------------------:|:------------------------------:|:----------------------:|
|      Default      |            22_788            |             39_619             |       53_004_327       |
|   With methods    |            27_126            |             33_973             |       56_714_270       |
| With externalize  |            26_948            |             33_673             |       58_714_940       |
|      Custom       |             596              |              657               |       40_711_673       |

#### После добавления возможности обработки null объектов

| Type of serialize | Serialization time,<br/>`ms` | Deserialization time,<br/>`ms` | File size,<br/>`bytes` |
|:-----------------:|:----------------------------:|:------------------------------:|:----------------------:|
|      Default      |            9_687             |             17_083             |       20_489_962       |
|   With methods    |            13_528            |             14_298             |       21_613_996       |
| With externalize  |            12_830            |             13_716             |       22_342_761       |
|      Custom       |             390              |              436               |       15_858_820       |
___

<h3 align="center">Выводы</h3>

### ObjectStreams, DataStreams и BufferedStream
Стоит обратить внимание, что если в `custom` сериализации использовать `DataStream` вместо `ObjectStream`, получаем значительно уступающие показатели по времени у `custom`. В последних версиях `Java` была сильно оптимизирована JVM для использования `ObjectStreams`, поскольку это наиболее распространенный способ записи и чтения данных и, таким образом, находится на критическом пути производительности `Java`.

Приведем в качестве примера тест на `DataStream` с реализацией записи и чтения null:

| Type of serialize | Serialization time,<br/>`ms` | Deserialization time,<br/>`ms` | File size,<br/>`bytes` |
|:-----------------:|:----------------------------:|:------------------------------:|:----------------------:|
|      Default      |            9_788             |             16_619             |       20_004_327       |
|   With methods    |            12_943            |             14_773             |       21_614_270       |
| With externalize  |            12_009            |             14_008             |       22_314_940       |
|      Custom       |            20_390            |             19_469             |       15_711_673       |

Как видно из результатов, `custom` работает значительно медленнее, при этом потерь по памяти нет.

Рассмотрим еще один пример, в котором будем использовать `DataStream`, но уже совместно с `BufferedStream`.
Для равных условий также добавим `BufferedStream` в другие реализации:

>`try (ObjectOutputStream oos = newObjectOutputStream(new BufferedOutputStream(Files.newOutputStream(file))))`
и
>`try (DataOutputStream oos = newDataOutputStream(new BufferedOutputStream(Files.newOutputStream(file))))`

Аналогично и с Input. Получили такие результаты:

| Type of serialize | Serialization time,<br/>`ms` | Deserialization time,<br/>`ms` | File size,<br/>`bytes` |
|:-----------------:|:----------------------------:|:------------------------------:|:----------------------:|
|      Default      |            1_250             |              560               |       20_504_742       |
|   With methods    |            1_300             |              981               |       21_598_458       |
| With externalize  |            1_479             |              891               |       22_409_062       |
|      Custom       |             350              |              630               |       15_870_165       |

В результате получили значительную оптимизацию по времени. Стоит заметить, что результаты `custom` при прочих равных не будут отличаться, если мы будем использовать `DataStream` совместно с `BufferedStream` или просто `ObjectStream`.
Будем везде испозьвать `ObjectStream` для `default` реализаций и `DataStream` совместно с `BufferedStream` для `custom`, поскольку в ручной сериализации предпочтительнее использовать `DataStream`. 
____

<h3 align="center">До добавления возможности обработки null объектов</h3>

`Default` показала лучшие результаты сериализации, чем `with methods` и `externalizable`, благодаря оптимизации, и при
этом худшие в десериализации из-за `reflection`.
Внутренний механизм Serializable во время работы генерирует большой объем служебной информации
и разного рода временных данных, предназначен для работы с любым объектом и может хранить данные,
которые не нужны для восстановления состояния объекта. В результате мы имеем большие по
сравнению с `custom` реализацией затраты по памяти и времени.
____

`Serialize with methods` и `externalizable` в сумме работают примерно также, как `default`.
`Externalizable` работает быстрее `with methods`, поскольку требует публичный конструктор без аргументов,
что позволяет экономить время на `reflection`. `With methods` и `externalizable` тратят
больше памяти, чем `default`, поскольку записывают метаинформацию о классах.
____
`Custom сериализация` показывает лучшие результаты как по времени, так и по памяти.
В данном виде сериализации записываются и считываются только строки и примитивные типы.
Нет необходимости сохранять большой объем служебной информации.
____

<h3 align="center">После добавления возможности обработки null объектов</h3>

Получили аналогичные результаты, но уже с данными, имеющими примерно в 2 раза меньший размер.
Поскольку в тестах генерируется достаточно большое количество `null` объектов, которые не пишутся и, соответственно, не читаются, обход по всем элементам занимает меньше времени и памяти.
В процессе реализации `serializer` было замечено, что можно более эффективно записывать `null` и `boolean`,
теперь они ложатся в один байт. 